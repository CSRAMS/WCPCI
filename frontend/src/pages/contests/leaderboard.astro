---
import BreadCrumb from "@/components/BreadCrumb.astro";
import Link from "@/components/Link.astro";
import Progress from "@/components/Progress.astro";
import Title from "@/components/Title.astro";
import TableCol from "@/components/table/TableCol.astro";
import TemplatedTable from "@/components/table/TemplatedTable.astro";
import Else from "@/components/tera/Else.astro";
import For from "@/components/tera/For.astro";
import If from "@/components/tera/If.astro";
import Tag from "@/components/tera/Tag.astro";
import Variable from "@/components/tera/Variable.astro";
import ContestLayout from "@/layouts/ContestLayout.astro";
import { variable } from "@/lib/tera";
import { Icon } from "astro-icon/components";

const description = `Leaderboard for ${variable("contest.name")} on ${variable("branding.name")}`;
---

<ContestLayout
    showAdminVar="is_admin or is_judge"
    path=`/contests/${variable("contest.id")}/leaderboard`
    title="Leaderboard"
    description={description}
    makeTile
>
    <BreadCrumb
        entries={[
            ["Contests", "/contests"],
            [variable("contest.name"), `/contests/${variable("contest.id")}/`],
            ["Leaderboard", `/contests/${variable("contest.id")}/leaderboard`]
        ]}
    />
    <div class="flex flex-row gap-4">
        <Title
            id="dataElem"
            class="grow"
            data-contest-penalty={variable("contest.penalty")}
            data-contest-id={variable("contest.id")}
            data-contest-start-time={variable("start_local_html")}
            data-contest-end-time={variable("end_local_html")}
            >Leaderboard for <Variable expression="contest.name" /></Title
        >
        <If expression="is_running or not has_started">
            <div
                id="live-indicator"
                data-live="false"
                class="group flex flex-row gap-1 text-lg font-bold"
            >
                <Icon
                    size={24}
                    name="tabler:circle-filled"
                    class="my-auto hidden animate-pulse text-red-500 group-[[data-live=true]]:inline"
                />
                <Icon
                    size={24}
                    name="tabler:circle-x"
                    class="my-auto hidden text-gray-500 group-[[data-live=false]]:inline"
                />
                <span class="my-auto hidden text-gray-500 group-[[data-live=false]]:inline"
                    >Not Live, Please Refresh</span
                >
                <span class="my-auto hidden text-red-500 group-[[data-live=true]]:inline">Live</span
                >
            </div>
            <Else>
                <div class="my-4 flex flex-row gap-2 text-blue-500">
                    <Icon size={24} name="tabler:info-circle" class="my-auto" />
                    <span class="font-bold">This Contest has Ended!</span>
                </div>
            </Else>
        </If>
    </div>

    <If expression="is_running">
        <div class="my-4 flex flex-row gap-4">
            <If expression="contest.freeze_time != 0">
                <div
                    id="frozen-msg"
                    data-frozen={variable("is_frozen")}
                    class="hidden flex-row gap-2 text-blue-500 data-[frozen='true']:flex"
                >
                    <Icon size={24} name="tabler:snowflake" class="my-auto" />
                    <span class="my-auto font-bold">Leaderboard Frozen!</span>
                </div>
            </If>
            <div class="relative grow">
                <If expression="contest.freeze_time != 0">
                    <span
                        style={`left: ${variable("freeze_percent")}%;`}
                        class="absolute inset-y-0 right-auto w-1 bg-blue-400"></span>
                    <Icon
                        style={`left: calc(${variable("freeze_percent")}% - 10px);`}
                        size={24}
                        name="tabler:snowflake"
                        class="absolute right-auto top-[-26px] text-blue-500"
                    />
                </If>
                <Progress
                    id="countdown-progress"
                    data-frozen={variable("is_frozen")}
                    data-frozen-time={variable("contest.freeze_time")}
                    class="h-full w-full data-[frozen='true']:border-2 data-[frozen='true']:border-solid data-[frozen='true']:border-blue-400"
                    aria-label="Time Left"
                    value={variable("progress")}
                    max="100"
                />
            </div>
            <span class="font-bold" id="countdown">Ends In --h --m --s</span>
        </div>
    </If>

    <div class="flex flex-row gap-4 text-xl">
      <span class="flex flex-row gap-1">
        <Icon
            name="tabler:circle-x"
            class="my-auto text-gray-500"
        />
        Rejected
      </span>
      <span class="flex flex-row gap-1">
        <Icon
            name="tabler:circle-check"
            class="my-auto text-green-600"
        />
        Accepted
      </span>
      <span class="flex flex-row gap-1">
        <Icon
            name="tabler:clock-check"
            class="my-auto text-green-600"
        />
        First to Solve
      </span>
    </div>

    <TemplatedTable
        addColSpan={100}
        id="leaderboard"
        idColName="user.id"
        rowId={`participant-row-${variable("entry.p_id")}`}
        emptyText="No one has joined this contest yet!"
        listName="entries"
        itemName="entry"
        columns={[
            {
                name: "loop.index",
                forceNoPrefix: true,
                label: "Place",
                placeIndicator: "place-indicator",
                centerHeader: true
            },
            {
                name: "user.display_name | default(value=entry.user.default_display_name)",
                avatarVar: "entry.user",
                label: "User",
                makeLink: `/profile/${variable("entry.user.id")}`,
                youIndicatorUserVar: "entry.user"
            }
        ]}
    >
        <For slot="head" sourceList="problems" itemName="problem">
            <TableCol class="text-center" as="th" scope="column">
                <If expression="has_started or is_admin or is_judge">
                    <Link
                        color="accent"
                        underline
                        href={`/contests/${variable("contest.id")}/problems/${variable("problem.slug")}`}
                    >
                        <Variable expression="problem.name" />
                    </Link>
                    <Else slot="else">
                        Problem <Variable expression="loop.index" />
                    </Else>
                </If>
            </TableCol>
        </For>
        <For sourceList="problems" itemName="problem">
            <Tag expression="set problem_id=problem.id | as_str" />
            <TableCol
                data-status={variable("problem_id in entry.scores")}
                data-first={variable("first_map[problem_id] | default(value=-1) == entry.p_id")}
                class="group"
                id=`problem-completion-indication-${variable("entry.p_id")}-${variable("problem.id")}`
            >
                <div
                    class="flex h-full flex-col justify-center whitespace-nowrap align-middle font-mono"
                >
                    <div class="relative mx-auto grow">
                        <Icon
                            size={20}
                            name="tabler:clock-check"
                            class="absolute inset-y-0 left-[calc(-15px+-0.5rem)] my-auto hidden text-green-600 group-[[data-first=true]]:inline"
                        />
                        <Icon
                            size={30}
                            name="tabler:circle-x"
                            class="hidden text-gray-500 group-[[data-status=false]]:inline"
                        />
                        <Icon
                            size={30}
                            name="tabler:circle-check"
                            class="hidden text-green-600 group-[[data-status=true]]:inline"
                        />
                    </div>
                    <div class="time-taken self-stretch text-center">
                        <Variable
                            expression="format_time_taken(time=entry.scores[problem_id].time_taken | default(value=-1))"
                        />
                    </div>
                    <div class="penalty self-stretch text-center">
                        <Variable
                            expression="entry.scores[problem_id].num_wrong | default(value=0)"
                        /> (+<Variable
                            expression="entry.scores[problem_id].num_wrong | default(value=0) * contest.penalty"
                        />m)
                    </div>
                </div>
            </TableCol>
        </For>
    </TemplatedTable>
</ContestLayout>

<script>
    import { makeCountdown } from "@/lib/countdown";
    import confetti from "canvas-confetti";
    import type { Message, ScoreEntry } from "@/lib/leaderboard_ws";

    const formatTimeTaken = (time: number) => {
        const hours = Math.floor(time / 60);
        const minutes = time % 60;
        return `${hours === 0 ? "" : `${hours}h `}${minutes.toString()}m`;
    };

    const dataElem = document.getElementById("dataElem")! as HTMLElement;
    const contestId = dataElem.getAttribute("data-contest-id")!;
    const contestPenalty = parseInt(dataElem.getAttribute("data-contest-penalty")!);
    const startTime = new Date(dataElem.getAttribute("data-contest-start-time")!);
    const endTime = new Date(dataElem.getAttribute("data-contest-end-time")!);
    const liveIndicator = document.getElementById("live-indicator");
    const countdown = document.getElementById("countdown");
    const countdownProgress = document.getElementById(
        "countdown-progress"
    ) as HTMLProgressElement | null;

    if (countdown && countdownProgress) {
        const frozenMessage = document.getElementById("frozen-msg") as HTMLElement;
        const totalSeconds = (endTime.getTime() - startTime.getTime()) / 1000;
        const freezeTime = countdownProgress.dataset.frozenTime;
        let frozen = countdownProgress.dataset.frozen === "true";
        const onTick = (time: string, seconds: number) => {
            if (countdown) {
                countdown.textContent = `Ends in ${time}`;
            }
            if (countdownProgress) {
                countdownProgress.value = ((totalSeconds - seconds) / totalSeconds) * 100;
            }
            const minutesLeft = seconds / 60;
            if (!frozen && minutesLeft < parseInt(freezeTime!)) {
                frozen = true;
                countdownProgress.dataset.frozen = "true";
                if (frozenMessage) {
                    frozenMessage.dataset.frozen = "true";
                }
            }
        };
        const onEnd = () => {
            const contestEndedMessage = encodeURIComponent("Contest Ended!");
            window.location.href = `${window.location.href}?ended=true&msg=${contestEndedMessage}&msg_type=success`;
        };
        makeCountdown(endTime, onTick, onEnd);
    }
    if (window.location.search.includes("ended=true")) {
        history.replaceState({}, document.title, window.location.pathname);
        const options = {
            particleCount: 2,
            disableForReducedMotion: true,
            spread: 55,
            colors: ["#8f4999", "#ffe800"]
        };
        const end = Date.now() + 1000 * 10;
        (function frame() {
            confetti({
                ...options,
                angle: 60,
                origin: { x: 0 }
            });
            confetti({
                ...options,
                angle: 120,
                origin: { x: 1 }
            });

            if (Date.now() < end) {
                requestAnimationFrame(frame);
            }
        })();
    }

    const updateScore = (participantId: number, problemId: number, score: ScoreEntry) => {
        const elem = document.getElementById(
            `problem-completion-indication-${participantId}-${problemId}`
        )!;
        elem.setAttribute("data-status", "true");
        const timeTakenElem = elem.querySelector(".time-taken")!;
        const penaltyElem = elem.querySelector(".penalty")!;
        timeTakenElem.textContent = formatTimeTaken(score.time_taken);
        penaltyElem.textContent = `${score.num_wrong} (+${score.num_wrong * contestPenalty}m)`;
    };

    const unComplete = (participantId: number, problemId: number) => {
        const elem = document.getElementById(
            `problem-completion-indication-${participantId}-${problemId}`
        )!;
        elem.setAttribute("data-status", "false");
        const timeTakenElem = elem.querySelector(".time-taken")!;
        const penaltyElem = elem.querySelector(".penalty")!;
        timeTakenElem.textContent = "--";
        penaltyElem.textContent = "0 (+0m)";
    };

    const setFirst = (participantId: number, problemId: number, isFirst: boolean) => {
        const elem = document.getElementById(
            `problem-completion-indication-${participantId}-${problemId}`
        )!;
        elem.setAttribute("data-first", isFirst.toString());
    };

    const rePlace = (participantId: number, _oldPos: number, newPos: number) => {
        const row = document.getElementById(`participant-row-${participantId}`);
        if (row) {
            const indicator = row.querySelector(".place-indicator")! as HTMLElement;
            indicator.dataset.place = (newPos + 1).toString();
            const text = indicator.querySelector(".place-text")!;
            text.textContent = (newPos + 1).toString();
        }
    };

    const transition = "transform 1s cubic-bezier(.35,-0.25,.3,1.1)";

    const reOrder = (newOrder: number[]) => {
        const table = document.getElementById("leaderboard")!.querySelector("tbody")!;
        [...table.children]
            .map((node, i) => [i, newOrder[i], node])
            .sort(([__, a, _], [____, b, ___]) => (a as number) - (b as number))
            .forEach(([oldPos, newPos, node]) => {
                table.appendChild(node as Node);
                const rowHeight = (node as Element).getBoundingClientRect().height;
                const multiplier = (oldPos as number) - (newPos as number);
                const transform = `translateY(${multiplier * rowHeight}px)`;
                [...(node as Element).children].forEach((child) => {
                    let childElem = child as HTMLElement;
                    childElem.style.transform = transform;
                    childElem.style.transition = "";
                });
            });
        setTimeout(resetPositions, 0);
    };

    const resetPositions = () => {
        const table = document.getElementById("leaderboard")!.querySelector("tbody")!;
        [...table.children].forEach((node, _) => {
            [...node.children].forEach((child) => {
                let childElem = child as HTMLElement;
                childElem.style.transition = transition;
                childElem.style.transform = "";
            });
        });
    };

    const onMessage = (msg: Message) => {
        console.debug("Received message", msg);
        switch (msg.type) {
            case "fullRefresh":
                window.location.reload();
                break;
            case "completion":
                updateScore(msg.participantId, msg.score.id, msg.score);
                break;
            case "unComplete":
                unComplete(msg.participantId, msg.problemId);
                break;
            case "completedFirst":
                setFirst(msg.participantId, msg.problemId, msg.isFirst);
                break;
            case "reOrder":
                Object.entries(msg.participantMap).forEach(([participantId, [oldPos, newPos]]) => {
                    rePlace(parseInt(participantId), oldPos, newPos);
                });
                const newOrder = Object.values(msg.participantMap)
                    .sort(([a, _], [b, __]) => {
                        return a - b;
                    })
                    .map(([_, newN]) => newN);
                reOrder(newOrder);
                break;
        }
    };

    const onOpen = () => {
        if (liveIndicator) {
            liveIndicator.dataset.live = "true";
        }
    };

    const onClose = () => {
        if (liveIndicator) {
            liveIndicator.dataset.live = "false";
        }
    };

    import("@/lib/leaderboard_ws").then((c) => {
        c.default(parseInt(contestId), onMessage, onClose, onOpen);
    });
</script>
